package us.theatr.spray.nozzle

/*
Copyright 2012 Yann Ramin

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import sun.misc.{BASE64Encoder, BASE64Decoder}
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec
import java.security.{Security, SecureRandom}
import org.bouncycastle.jce.provider.BouncyCastleProvider

/**
 * A standard/boring way to store passwords safely using PBKDF#2
 * and a random salt. All parameters are encoded into the salt text string
 * to allow porting of the default algorithms and iterations at a later date.
 */
object PasswordUtil {

	/**
	 * The default iterations parameter - this is the number of rounds of PBKDF#2 to run
	 */
	val iterations = 200000
	/**
	 * The default algorithm for hashing. Certain algorithms require GnuCrypto,
	 * such as HmacSHA256
	 */
	val default_algo = "PBKDF2WithHmacSHA1"

	/**
	 * This must match the expected output of the algorithm in question.
	 */
	val hash_length = 160

	/**
	 * Given a user password, the hashed password from the datastore, and the stored salt, check
	 * if the password matches.
	 * @param password User supplied password
	 * @param dbpassword Data-store password - previously generated by securePassword
	 * @param salt Data-store salt - previously generated by securePassword
	 * @return
	 */
	def checkPassword(password: String, dbpassword: String, salt: String) : Boolean = {
		val spl = salt.split(':')

		val saltarray = new BASE64Decoder().decodeBuffer(spl(2))
		val algo = spl(0)
		val iter = spl(1).toInt
		securePassword(password, saltarray, iter, algo)._1 == dbpassword
	}

	/**
	 * Secure a password given in password. All other parameters are default.
	 * @param password User supplied password
	 * @param salt (optional)
	 * @param iter (optional) Number of iterations
	 * @param algo (optional) Algorithm
	 * @param hash_len (optional) Hash length output
	 * @return A tuple of Strings containing: (Base64(password_hash), Salt)
	 */
	def securePassword(password: String, salt: Array[Byte] = generateSalt, iter: Int = iterations, algo: String = default_algo, hash_len: Int = hash_length) : (String, String) = {
		val fac = SecretKeyFactory.getInstance(algo)

		val pbks = new PBEKeySpec(password.toCharArray, salt, iterations, hash_len)
		(new BASE64Encoder().encode(fac.generateSecret(pbks).getEncoded),
			algo + ":" + iterations.toString + ":" + new BASE64Encoder().encode(salt))
	}

	/**
	 * Generate a salt (random array of bytes)
	 * @return Array of random bytes
	 */
	def generateSalt : Array[Byte] = {
		val bytes = Array.fill(128) {0.toByte}
		new SecureRandom().nextBytes(bytes)
		bytes
	}
}
